/******************************************************************************\
    empowerd - empowers the offline smart home
    Copyright (C) 2019 - 2022 Max Maisel

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
\******************************************************************************/
use super::*;
use bytes::BytesMut;
use std::io::Cursor;

const BUFFER_SIZE: usize = 128;
const SMA_FOURCC: u32 = 0x534d4100;

fn setup_inv_header(header: &mut SmaInvHeader) {
    header.dst.susy_id = 0xFFFF;
    header.dst.serial = 0xFFFFFFFF;
    header.packet_id = 0x8001;
    header.app.susy_id = 0x7800;
    header.app.serial = 0x50713a38;
}

#[test]
fn serialize_identify() {
    let expected_binary: Vec<u8> = vec![
        0x53, 0x4d, 0x41, 0x00, 0x00, 0x04, 0x02, 0xa0, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x26, 0x00, 0x10, 0x60, 0x65, 0x09, 0xa0, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x78, 0x00, 0x50, 0x71, 0x3a, 0x38, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // TODO: are those 0x00 necessary?
        0x00, 0x00, 0x00, 0x00,
    ];
    let mut buffer = BytesMut::with_capacity(BUFFER_SIZE);
    let mut cmd = SmaCmdIdentify::new();
    setup_inv_header(&mut cmd.inv_header);
    cmd.serialize(&mut buffer);

    assert_eq!(
        expected_binary,
        buffer.to_vec(),
        "Identify serialized incorrectly"
    );
}

#[test]
fn deserialize_identify() {
    let mut input_buffer = Cursor::new(vec![
        0x53, 0x4d, 0x41, 0x00, 0x00, 0x04, 0x02, 0xa0, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x4e, 0x00, 0x10, 0x60, 0x65, 0x13, 0x90, 0x7d, 0x00, 0xeb, 0x7b,
        0xb8, 0x33, 0x00, 0x00, 0x8a, 0x00, 0xd5, 0x66, 0xfb, 0x7e, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xd4, 0x73, 0x00, 0x20, 0x01, 0x00, 0x8a, 0x00, 0xd5, 0x66,
        0xfb, 0x7e, 0x00, 0x00, 0x0a, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ]);
    let fourcc = input_buffer.get_u32();
    assert_eq!(SMA_FOURCC, fourcc);
    let response = parse_command(&mut input_buffer, &None);
    let response = match response {
        Err(e) => panic!("Parse identify response failed: {}", e),
        Ok(x) => x,
    };
    let parsed_endpoint = match response.extract_data() {
        SmaData::Endpoint(ep) => ep,
        _ => panic!("Extracted incorrect data from identify response"),
    };

    assert_eq!(parsed_endpoint.susy_id, 0x8a00, "wrong susy_id");
    assert_eq!(parsed_endpoint.serial, 0xd566fb7e, "wrong serial");
    assert_eq!(parsed_endpoint.ctrl, 0x00, "wrong ctrl");
}

#[test]
fn serialize_login() {
    let expected_binary: Vec<u8> = vec![
        0x53, 0x4d, 0x41, 0x00, 0x00, 0x04, 0x02, 0xa0, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x3a, 0x00, 0x10, 0x60, 0x65, 0x0e, 0xa0, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0x01, 0x78, 0x00, 0x50, 0x71, 0x3a, 0x38, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x0c, 0x04, 0xfd, 0xff, 0x07, 0x00,
        0x00, 0x00, 0x84, 0x03, 0x00, 0x00, 0xfc, 0xd4, 0xba, 0x5c, 0x00, 0x00,
        0x00, 0x00, 0xb8, 0xb8, 0xb8, 0xb8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
        0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
    ];
    let mut buffer = BytesMut::with_capacity(BUFFER_SIZE);
    let mut cmd = SmaCmdLogin::new(&None);
    setup_inv_header(&mut cmd.inv_header);
    cmd.set_password(&"0000".to_string());
    cmd.timestamp = 0x5cbad4fc;
    cmd.serialize(&mut buffer);

    assert_eq!(expected_binary, buffer.to_vec());
}

#[test]
fn deserialize_login() {
    let mut input_buffer = Cursor::new(vec![
        0x53, 0x4d, 0x41, 0x00, 0x00, 0x04, 0x02, 0xa0, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x3a, 0x00, 0x10, 0x60, 0x65, 0x0e, 0xd0, 0x7d, 0x00, 0xeb, 0x7b,
        0xb8, 0x33, 0x00, 0x01, 0x8a, 0x00, 0xd5, 0x66, 0xfb, 0x7e, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x0d, 0x04, 0xfd, 0xff, 0x07, 0x00,
        0x00, 0x00, 0x84, 0x03, 0x00, 0x00, 0x32, 0x8f, 0xcd, 0x5c, 0x00, 0x00,
        0x00, 0x00, 0xb8, 0xb8, 0xb8, 0xb8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
        0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
    ]);
    let fourcc = input_buffer.get_u32();
    assert_eq!(SMA_FOURCC, fourcc);
    let response = parse_command(&mut input_buffer, &None);
    let response = match response {
        Err(e) => panic!("Parse login response failed: {}", e),
        Ok(x) => x,
    };
    match response.extract_data() {
        SmaData::None() => (),
        _ => panic!("Extracted incorrect data from login response"),
    }
}

#[test]
fn deserialize_login2() {
    let mut input_buffer = Cursor::new(vec![
        0x53, 0x4D, 0x41, 0x00, 0x00, 0x04, 0x02, 0xA0, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x2E, 0x00, 0x10, 0x60, 0x65, 0x0B, 0xE0, 0xDE, 0xAD, 0xDE, 0xAD,
        0xBE, 0xEA, 0x00, 0x01, 0x98, 0x01, 0x36, 0xE3, 0x39, 0xB3, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x0D, 0x04, 0xFD, 0xFF, 0x07, 0x00,
        0x00, 0x00, 0x84, 0x03, 0x00, 0x00, 0xD9, 0xAA, 0xD4, 0x5E, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]);
    let fourcc = input_buffer.get_u32();
    assert_eq!(SMA_FOURCC, fourcc);
    let response = parse_command(&mut input_buffer, &None);
    let response = match response {
        Err(e) => panic!("Parse login response failed: {}", e),
        Ok(x) => x,
    };
    match response.extract_data() {
        SmaData::None() => (),
        _ => panic!("Extracted incorrect data from login response"),
    }
}

#[test]
fn deserialize_failed_login() {
    let mut input_buffer = Cursor::new(vec![
        0x53, 0x4d, 0x41, 0x00, 0x00, 0x04, 0x02, 0xa0, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x3a, 0x00, 0x10, 0x60, 0x65, 0x0e, 0xd0, 0x7d, 0x00, 0xeb, 0x7b,
        0xb8, 0x33, 0x00, 0x01, 0x8a, 0x00, 0xd5, 0x66, 0xfb, 0x7e, 0x00, 0x01,
        0x00, 0x01, 0x00, 0x00, 0x03, 0x80, 0x0d, 0x04, 0xfd, 0xff, 0x07, 0x00,
        0x00, 0x00, 0x84, 0x03, 0x00, 0x00, 0x32, 0x8f, 0xcd, 0x5c, 0x00, 0x00,
        0x00, 0x00, 0xb8, 0xb8, 0xb8, 0xb8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
        0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
    ]);
    let response = parse_command(&mut input_buffer, &None);
    match response {
        Err(_e) => (),
        Ok(_x) => panic!("Did not detected error bit"),
    };
}

#[test]
fn serialize_logout() {
    let expected_binary: Vec<u8> = vec![
        0x53, 0x4d, 0x41, 0x00, 0x00, 0x04, 0x02, 0xa0, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x22, 0x00, 0x10, 0x60, 0x65, 0x08, 0xa0, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0x03, 0x78, 0x00, 0x50, 0x71, 0x3a, 0x38, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x0e, 0x01, 0xfd, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    ];
    let mut buffer = BytesMut::with_capacity(BUFFER_SIZE);
    let mut cmd = SmaCmdLogout::new();
    setup_inv_header(&mut cmd.inv_header);
    cmd.serialize(&mut buffer);

    assert_eq!(expected_binary, buffer.to_vec());
}

#[test]
fn serialize_get_day_data() {
    let expected_binary: Vec<u8> = vec![
        0x53, 0x4d, 0x41, 0x00, 0x00, 0x04, 0x02, 0xa0, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x26, 0x00, 0x10, 0x60, 0x65, 0x09, 0xe0, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x78, 0x00, 0x50, 0x71, 0x3a, 0x38, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x02, 0x00, 0x70, 0xb4, 0xb8,
        0xcc, 0x5c, 0x34, 0x0a, 0xce, 0x5c, 0x00, 0x00, 0x00, 0x00,
    ];
    let mut buffer = BytesMut::with_capacity(BUFFER_SIZE);
    let mut cmd = SmaCmdGetDayData::new();
    setup_inv_header(&mut cmd.inv_header);
    cmd.start_time = 0x5cccb8b4;
    cmd.end_time = 0x5cce0a34;
    cmd.serialize(&mut buffer);

    assert_eq!(expected_binary, buffer.to_vec());
}

#[test]
fn deserialize_get_day_data() {
    let mut input_buffer = Cursor::new(vec![
        0x53, 0x4d, 0x41, 0x00, 0x00, 0x04, 0x02, 0xa0, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x56, 0x00, 0x10, 0x60, 0x65, 0x15, 0xd0, 0xde, 0xad, 0xde, 0xad,
        0xbe, 0xea, 0x00, 0xa0, 0x8a, 0x00, 0xd5, 0x66, 0xfb, 0x7e, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 0x01, 0x02, 0x00, 0x70, 0x45, 0x27,
        0x00, 0x00, 0x48, 0x27, 0x00, 0x00, 0xdc, 0x60, 0xed, 0x5c, 0xf6, 0x97,
        0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x62, 0xed, 0x5c, 0xff, 0x97,
        0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x63, 0xed, 0x5c, 0x08, 0x98,
        0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x64, 0xed, 0x5c, 0x10, 0x98,
        0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]);
    let fourcc = input_buffer.get_u32();
    assert_eq!(SMA_FOURCC, fourcc);
    let response = parse_command(&mut input_buffer, &None);
    let response = match response {
        Err(e) => panic!("Parse get day data response failed: {}", e),
        Ok(x) => x,
    };
    let received_data = match response.extract_data() {
        SmaData::IntTimeSeries(x) => x,
        _ => panic!("Extracted incorrect data from get day data response"),
    };

    let expected_data = vec![
        TimestampedInt {
            timestamp: 1559060700,
            value: 12752886,
        },
        TimestampedInt {
            timestamp: 1559061000,
            value: 12752895,
        },
        TimestampedInt {
            timestamp: 1559061300,
            value: 12752904,
        },
        TimestampedInt {
            timestamp: 1559061600,
            value: 12752912,
        },
    ];
    assert_eq!(expected_data, received_data);
}

#[test]
fn serialize_energymeter() {
    let expected_binary = vec![
        0x53, 0x4D, 0x41, 0x00, 0x00, 0x04, 0x02, 0xA0, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x28, 0x00, 0x10, 0x60, 0x69, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
        0xAA, 0xBB, 0xCC, 0xDD, 0x00, 0x01, 0x04, 0x00, 0x01, 0x02, 0x03, 0x04,
        0x00, 0x01, 0x08, 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80,
        0x90, 0x00, 0x00, 0x00, 0x02, 0x00, 0x12, 0x52, 0x00, 0x00, 0x00, 0x00,
    ];
    let mut buffer = BytesMut::with_capacity(BUFFER_SIZE);
    let mut msg = SmaEmMessage::new();
    msg.em_header.susy_id = 0x1122;
    msg.em_header.serial = 0x33445566;
    msg.em_header.timestamp_ms = 0xAABBCCDD;
    msg.payload = SmaEmPayload::new();
    msg.payload.0 = BTreeMap::from([
        (0x010400, 0x01020304),
        (0x010800, 0x1020304050607080),
        (0x90000000, 0x02001252),
    ]);

    msg.update_len();
    msg.serialize(&mut buffer);

    assert_eq!(expected_binary, buffer.to_vec());
}

#[test]
fn deserialize_energymeter() {
    let mut input_buffer = Cursor::new(vec![
        0x53, 0x4D, 0x41, 0x00, 0x00, 0x04, 0x02, 0xA0, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x30, 0x00, 0x10, 0x60, 0x69, 0x01, 0x5D, 0x71, 0x55, 0xA8, 0xA3,
        0xA1, 0x7F, 0x67, 0x61, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x10, 0x00, 0xA8,
        0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x90, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x12, 0x52, 0x00, 0x00, 0x00, 0x00,
    ]);

    let fourcc = input_buffer.get_u32();
    assert_eq!(SMA_FOURCC, fourcc);
    let response = parse_command(&mut input_buffer, &None);
    let response = match response {
        Ok(x) => x,
        Err(e) => panic!("Parse EM message failed: {}", e),
    };

    let received_header = match response.get_header() {
        SmaHeader::Em(x) => x,
        _ => panic!("Received incorrect SMA header"),
    };

    let expected_header = SmaEmHeader {
        susy_id: 0x15D,
        serial: 0x7155A8A3,
        timestamp_ms: 0xA17F6761,
    };
    assert_eq!(expected_header, *received_header);

    let received_data = match response.extract_data() {
        SmaData::EmPayload(x) => x,
        _ => panic!("Extracted incorrect data from EM message"),
    };

    let expected_data = BTreeMap::from([
        (0x010400, 0),
        (0x010800, 0x1A1000A8),
        (0x020400, 0x1A),
        (0x90000000, 0x02001252),
    ]);
    assert_eq!(expected_data, received_data);
}

#[test]
fn reject_random_junk() {
    let mut input_buffer = Cursor::new(vec![
        0xCB, 0xF2, 0x87, 0x99, 0xA7, 0x35, 0x70, 0x5E, 0xAE, 0x51, 0x2B, 0xEE,
        0xC9, 0x66, 0x08, 0xF2, 0x7F, 0x84, 0x54, 0x72, 0xC5, 0x23, 0x77, 0x2B,
        0xF1, 0x01, 0x3F, 0x27, 0xDC, 0x2F, 0x26, 0x05, 0xE8, 0xCC, 0xC4, 0xAC,
        0x38, 0x24, 0x47, 0xBD, 0x27, 0x28, 0xEB, 0x8A, 0x4A, 0x93, 0x97, 0x22,
        0xBC, 0x69, 0x68, 0x92, 0x07, 0x5D, 0xE4, 0xE8, 0x1D, 0x2D, 0xE0, 0x2D,
        0xB3, 0x8C, 0x22, 0x19,
    ]);
    let response = parse_command(&mut input_buffer, &None);
    match response {
        Err(_e) => (),
        Ok(_x) => panic!("Incorrectly recognized junk as valid"),
    };
}
